const { PDFDocument: e } = PDFLib; let mergeFiles = [], splitFile = null, splitFileDoc = null, selectedPages = new Set; const tabs = document.querySelectorAll(".tab-btn"), tabPanes = document.querySelectorAll(".tab-pane"), mergeUploadArea = document.getElementById("merge-upload-area"), mergeFileInput = document.getElementById("merge-file-input"), fileListEl = document.getElementById("file-list"), mergeBtn = document.getElementById("merge-btn"), mergeHelpText = document.getElementById("merge-help-text"), splitUploadArea = document.getElementById("split-upload-area"), splitFileInput = document.getElementById("split-file-input"), splitPreview = document.getElementById("split-preview"), pagesGrid = document.getElementById("pages-grid"), splitBtn = document.getElementById("split-btn"), splitModeRadios = document.getElementsByName("split-mode"), rangeInputContainer = document.getElementById("range-input-container"), rangeInput = document.getElementById("range-input"); function init() { setupTabs(), setupMergeEvents(), setupSplitEvents(), setupCompressEvents(), setupConvertEvents(), setupEditEvents(), setupSecurityEvents(), setupWelcomePopup() } function setupTabs() { tabs.forEach(e => { e.addEventListener("click", () => { tabs.forEach(e => e.classList.remove("active")), tabPanes.forEach(e => e.classList.remove("active")), e.classList.add("active"), document.getElementById(e.dataset.tab).classList.add("active") }) }) } function setupMergeEvents() { mergeUploadArea.addEventListener("dragover", e => { e.preventDefault(), mergeUploadArea.classList.add("dragover") }), mergeUploadArea.addEventListener("dragleave", () => { mergeUploadArea.classList.remove("dragover") }), mergeUploadArea.addEventListener("drop", e => { e.preventDefault(), mergeUploadArea.classList.remove("dragover"), handleMergeFiles(e.dataTransfer.files) }), mergeFileInput.addEventListener("change", e => { handleMergeFiles(e.target.files) }), mergeBtn.addEventListener("click", mergePDFs) } function handleMergeFiles(e) { let t = Array.from(e).filter(e => "application/pdf" === e.type); 0 !== t.length && (mergeFiles = [...mergeFiles, ...t], renderMergeList()) } function renderMergeList() {
    fileListEl.innerHTML = "", mergeFiles.forEach((e, t) => {
        let a = document.createElement("li"); a.className = "file-item", a.draggable = !0, a.dataset.index = t; let n = document.createElement("div"); n.className = "file-preview", n.id = `preview-${t}`, n.textContent = "...", a.innerHTML = `
            <div class="file-info">${e.name}</div>
            <div class="file-controls">
                <button onclick="moveFile(${t}, -1)" title="Move Up" class="btn-icon">
                    <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="18 15 12 9 6 15"></polyline></svg>
                </button>
                <button onclick="moveFile(${t}, 1)" title="Move Down" class="btn-icon">
                    <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                </button>
                <div class="separator"></div>
                <button class="remove btn-icon" onclick="removeFile(${t})" title="Remove">
                    <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                </button>
            </div>
        `, a.insertBefore(n, a.firstChild), a.addEventListener("dragstart", () => { a.classList.add("dragging") }), a.addEventListener("dragend", () => { a.classList.remove("dragging"), updateMergeFilesOrder() }), fileListEl.appendChild(a), generateThumbnail(e, t)
    }), mergeFiles.length > 0 ? (mergeHelpText.textContent = "Tip: Drag and drop files to reorder them. The top file will be the first page in the merged PDF.", mergeHelpText.classList.remove("hidden"), mergeBtn.disabled = !1) : (mergeHelpText.classList.add("hidden"), mergeBtn.disabled = !0)
} function getDragAfterElement(e, t) { let a = [...e.querySelectorAll(".file-item:not(.dragging)")]; return a.reduce((e, a) => { let n = a.getBoundingClientRect(), i = t - n.top - n.height / 2; return i < 0 && i > e.offset ? { offset: i, element: a } : e }, { offset: Number.NEGATIVE_INFINITY }).element } function updateMergeFilesOrder() { let e = [], t = fileListEl.querySelectorAll(".file-item"); t.forEach(t => { let a = parseInt(t.dataset.index); e.push(mergeFiles[a]) }); let a = [...mergeFiles]; mergeFiles = [], t.forEach(e => { let t = parseInt(e.dataset.index); mergeFiles.push(a[t]) }), renderMergeList() } async function generateThumbnail(e, t) { try { let a = await e.arrayBuffer(), n = pdfjsLib.getDocument(a), i = await n.promise, r = await i.getPage(1), l = r.getViewport({ scale: .5 }), o = document.createElement("canvas"), s = o.getContext("2d"); o.height = l.height, o.width = l.width, await r.render({ canvasContext: s, viewport: l }).promise; let d = document.getElementById(`preview-${t}`); d && (d.textContent = "", d.appendChild(o)) } catch (c) { console.error("Error generating thumbnail:", c); let g = document.getElementById(`preview-${t}`); g && (g.textContent = "Err") } } async function mergePDFs() { if (!(mergeFiles.length < 2)) try { mergeBtn.textContent = "Merging...", mergeBtn.disabled = !0; let t = await e.create(); for (let a of mergeFiles) { let n = await a.arrayBuffer(), i = await e.load(n), r = await t.copyPages(i, i.getPageIndices()); r.forEach(e => t.addPage(e)) } let l = await t.save(); triggerDownloadAnimation(mergeBtn), downloadFile(l, "merged.pdf") } catch (o) { console.error(o), showNotification("Error merging PDFs. See console for details.", "error") } finally { mergeBtn.textContent = "Merge PDF", mergeBtn.disabled = !1 } } function setupSplitEvents() { splitUploadArea.addEventListener("dragover", e => { e.preventDefault(), splitUploadArea.classList.add("dragover") }), splitUploadArea.addEventListener("dragleave", () => { splitUploadArea.classList.remove("dragover") }), splitUploadArea.addEventListener("drop", e => { e.preventDefault(), splitUploadArea.classList.remove("dragover"), handleSplitFile(e.dataTransfer.files[0]) }), splitFileInput.addEventListener("change", e => { handleSplitFile(e.target.files[0]) }); let e = document.getElementById("split-help-text"), t = t => { "all" === t ? e.textContent = "Tip: Select specific pages by clicking on them. If no pages are selected, all pages will be split into separate files." : e.textContent = "Enter a range of pages to extract (e.g., 1-5, 8, 11-13)." }; t("all"), Array.from(splitModeRadios).forEach(e => { e.addEventListener("change", e => { let a = e.target.value; t(a), "range" === a ? (rangeInputContainer.classList.remove("hidden"), selectedPages.clear(), document.querySelectorAll(".page-item.selected").forEach(e => e.classList.remove("selected"))) : rangeInputContainer.classList.add("hidden") }) }), splitBtn.addEventListener("click", splitPDF) } async function handleSplitFile(t) { if (t && "application/pdf" === t.type) { splitFile = t; try { let a = await t.arrayBuffer(); await renderSplitPreview((splitFileDoc = await e.load(a)).getPageCount()), splitPreview.classList.remove("hidden"), splitUploadArea.classList.add("hidden") } catch (n) { console.error(n), showNotification("Error loading PDF.", "error") } } } async function renderSplitPreview(e) { if (pagesGrid.innerHTML = "", selectedPages.clear(), splitFileDoc) for (let t = 1; t <= e; t++) { let a = document.createElement("div"); a.className = "page-item", a.dataset.pageIndex = t - 1, a.addEventListener("click", () => { togglePageSelection(t - 1, a) }); let n = document.createElement("div"); n.className = "page-canvas-container", a.appendChild(n); let i = document.createElement("div"); i.className = "page-label", i.textContent = `Page ${t}`, a.appendChild(i), pagesGrid.appendChild(a), renderPageThumbnail(splitFileDoc, t, n) } } function togglePageSelection(e, t) { let a = document.querySelector('input[name="split-mode"]:checked').value; "range" !== a && (selectedPages.has(e) ? (selectedPages.delete(e), t.classList.remove("selected")) : (selectedPages.add(e), t.classList.add("selected"))) } async function renderPageThumbnail(e, t, a) { try { if (!splitFile) return; let n = await splitFile.arrayBuffer(), i = pdfjsLib.getDocument(n), r = await i.promise, l = await r.getPage(t), o = l.getViewport({ scale: .3 }), s = document.createElement("canvas"), d = s.getContext("2d"); s.height = o.height, s.width = o.width, await l.render({ canvasContext: d, viewport: o }).promise, a.appendChild(s) } catch (c) { console.error(`Error rendering page ${t}:`, c), a.textContent = "Err" } } async function splitPDF() { if (!splitFileDoc) return; let t = document.querySelector('input[name="split-mode"]:checked').value, a = splitFileDoc.getPageCount(); try { if (splitBtn.textContent = "Splitting...", splitBtn.disabled = !0, "all" === t) { let n = []; for (let i of n = selectedPages.size > 0 ? Array.from(selectedPages).sort((e, t) => e - t) : Array.from({ length: a }, (e, t) => t)) { let r = await e.create(), [l] = await r.copyPages(splitFileDoc, [i]); r.addPage(l); let o = await r.save(); triggerDownloadAnimation(splitBtn), downloadFile(o, `page-${i + 1}.pdf`), await new Promise(e => setTimeout(e, 200)) } } else if ("range" === t) { let s = rangeInput.value.trim(); if (!s) { showNotification("Please enter a range.", "warning"), rangeInput.focus(), rangeInput.classList.add("input-error"), setTimeout(() => rangeInput.classList.remove("input-error"), 500); return } let d = parseRange(s, a); if (0 === d.length) { showNotification("Invalid range format.", "error"), rangeInput.focus(), rangeInput.classList.add("input-error"), setTimeout(() => rangeInput.classList.remove("input-error"), 500); return } let c = await e.create(), g = await c.copyPages(splitFileDoc, d); g.forEach(e => c.addPage(e)); let m = await c.save(); triggerDownloadAnimation(splitBtn), downloadFile(m, "split-range.pdf") } } catch (p) { console.error(p), showNotification("Error splitting PDF.", "error") } finally { splitBtn.textContent = "Split PDF", splitBtn.disabled = !1 } } function parseRange(e, t) { let a = new Set, n = e.split(","); return n.forEach(e => { let n = e.trim(); if (n.includes("-")) { let [i, r] = n.split("-").map(e => parseInt(e)); if (!isNaN(i) && !isNaN(r)) for (let l = i; l <= r; l++)l >= 1 && l <= t && a.add(l - 1) } else { let o = parseInt(n); !isNaN(o) && o >= 1 && o <= t && a.add(o - 1) } }), Array.from(a).sort((e, t) => e - t) } function showNotification(e, t = "info") {
    let a = document.querySelector(".notification-container"); a || ((a = document.createElement("div")).className = "notification-container", document.body.appendChild(a)); let n = document.createElement("div"); n.className = `notification ${t}`, n.innerHTML = `
        <div class="notification-message">${e}</div>
    `, a.appendChild(n), setTimeout(() => { n.style.animation = "fadeOut 0.3s forwards", n.addEventListener("animationend", () => { n.remove(), 0 === a.children.length && a.remove() }) }, 3e3)
} function triggerDownloadAnimation(e) { let t = e.getBoundingClientRect(), a = document.createElement("div"); a.className = "download-particle"; let n = t.left + t.width / 2 - 12, i = t.top + t.height / 2 - 16; a.style.left = `${n}px`, a.style.top = `${i}px`, document.body.appendChild(a); let r = window.innerWidth - 50; a.style.setProperty("--tx", `${r - n}px`), a.style.setProperty("--ty", `${50 - i}px`), requestAnimationFrame(() => { a.style.animation = "flyToTopRight 2s cubic-bezier(0.19, 1, 0.22, 1) forwards" }), a.addEventListener("animationend", () => { a.remove() }) } fileListEl.addEventListener("dragover", e => { e.preventDefault(); let t = getDragAfterElement(fileListEl, e.clientY), a = document.querySelector(".dragging"); null == t ? fileListEl.appendChild(a) : fileListEl.insertBefore(a, t) }), window.moveFile = (e, t) => { if (0 === e && -1 === t || e === mergeFiles.length - 1 && 1 === t) return; let a = mergeFiles[e]; mergeFiles[e] = mergeFiles[e + t], mergeFiles[e + t] = a, renderMergeList() }, window.removeFile = e => { mergeFiles.splice(e, 1), renderMergeList() }; let compressFile = null; function setupCompressEvents() { let e = document.getElementById("compress-upload-area"), t = document.getElementById("compress-file-input"), a = document.getElementById("compress-btn"); e.addEventListener("dragover", t => { t.preventDefault(), e.classList.add("dragover") }), e.addEventListener("dragleave", () => { e.classList.remove("dragover") }), e.addEventListener("drop", t => { t.preventDefault(), e.classList.remove("dragover"), handleCompressFile(t.dataTransfer.files[0]) }), t.addEventListener("change", e => { handleCompressFile(e.target.files[0]) }), a.addEventListener("click", compressPDF) } function handleCompressFile(e) { if (!e || "application/pdf" !== e.type) return; compressFile = e, document.getElementById("compress-upload-area").classList.add("hidden"), document.getElementById("compress-options-container").classList.remove("hidden"); let t = document.getElementById("compress-file-info"), a = (e.size / 1048576).toFixed(2); t.textContent = `Selected File: ${e.name} (${a} MB)` } async function compressPDF() { if (!compressFile) return; let t = document.getElementById("compress-btn"), a = document.querySelector('input[name="compress-level"]:checked').value, n = .7, i = 1; "low" === a ? (n = .4, i = 1) : "high" === a ? (n = .9, i = 2) : (n = .7, i = 1.5); try { t.textContent = "Compressing... (This may take a while)", t.disabled = !0; let r = await compressFile.arrayBuffer(), l = pdfjsLib.getDocument(r), o = await l.promise, s = o.numPages, d = await e.create(); for (let c = 1; c <= s; c++) { let g = await o.getPage(c), m = g.getViewport({ scale: i }), p = document.createElement("canvas"), f = p.getContext("2d"); p.height = m.height, p.width = m.width; let v = { canvasContext: f, viewport: m }; await g.render(v).promise; let u = p.toDataURL("image/jpeg", n), h = await fetch(u).then(e => e.arrayBuffer()), y = await d.embedJpg(h), E = d.addPage([y.width, y.height]); E.drawImage(y, { x: 0, y: 0, width: y.width, height: y.height }), t.textContent = `Compressing Page ${c} of ${s}...`, await new Promise(e => setTimeout(e, 10)) } let w = await d.save(); triggerDownloadAnimation(t), downloadFile(w, `compressed-${a}.pdf`) } catch (b) { console.error("Compression Error:", b), showNotification("Error compressing PDF.", "error") } finally { t.textContent = "Compress PDF", t.disabled = !1 } } function downloadFile(e, t) { let a = new Blob([e], { type: "application/pdf" }), n = URL.createObjectURL(a), i = document.createElement("a"); i.href = n, i.download = t, document.body.appendChild(i), i.click(), document.body.removeChild(i), URL.revokeObjectURL(n) } function setupConvertEvents() { let e = document.getElementsByName("convert-mode"); e.forEach(e => { e.addEventListener("change", e => { let t = e.target.value, a = document.querySelectorAll("#convert-tab .sub-tab-pane"); a.forEach(e => e.classList.remove("active")), document.getElementById(t).classList.add("active") }) }), setupConvertToPDFEvents() } let jpgFiles = [], wordFile = null, excelFile = null; function setupConvertToPDFEvents() { let e = document.getElementsByName("convert-to-type"); e.forEach(e => { e.addEventListener("change", e => { let t = e.target.value; document.getElementById("jpg-to-pdf-section").classList.add("hidden"), document.getElementById("word-to-pdf-section").classList.add("hidden"), document.getElementById("excel-to-pdf-section").classList.add("hidden"), "jpg-to-pdf" === t ? document.getElementById("jpg-to-pdf-section").classList.remove("hidden") : "word-to-pdf" === t ? document.getElementById("word-to-pdf-section").classList.remove("hidden") : "excel-to-pdf" === t && document.getElementById("excel-to-pdf-section").classList.remove("hidden") }) }); let t = document.getElementById("jpg-file-input"), a = document.getElementById("jpg-upload-area"), n = document.getElementById("jpg-convert-btn"); t.addEventListener("change", e => handleJPGFiles(e.target.files)), a.addEventListener("dragover", e => { e.preventDefault(), a.classList.add("dragover") }), a.addEventListener("dragleave", () => a.classList.remove("dragover")), a.addEventListener("drop", e => { e.preventDefault(), a.classList.remove("dragover"), handleJPGFiles(e.dataTransfer.files) }), n.addEventListener("click", convertJPGtoPDF); let i = document.getElementById("jpg-file-list"); i.addEventListener("dragover", e => { e.preventDefault(); let t = getDragAfterElement(i, e.clientY), a = document.querySelector(".dragging"); null == t ? i.appendChild(a) : i.insertBefore(a, t) }); let r = document.getElementById("word-file-input"), l = document.getElementById("word-upload-area"), o = document.getElementById("word-convert-btn"); r.addEventListener("change", e => handleWordFile(e.target.files[0])), l.addEventListener("dragover", e => { e.preventDefault(), l.classList.add("dragover") }), l.addEventListener("dragleave", () => l.classList.remove("dragover")), l.addEventListener("drop", e => { e.preventDefault(), l.classList.remove("dragover"), handleWordFile(e.dataTransfer.files[0]) }), o.addEventListener("click", convertWordToPDF); let s = document.getElementById("excel-file-input"), d = document.getElementById("excel-upload-area"), c = document.getElementById("excel-convert-btn"); s.addEventListener("change", e => handleExcelFile(e.target.files[0])), d.addEventListener("dragover", e => { e.preventDefault(), d.classList.add("dragover") }), d.addEventListener("dragleave", () => d.classList.remove("dragover")), d.addEventListener("drop", e => { e.preventDefault(), d.classList.remove("dragover"), handleExcelFile(e.dataTransfer.files[0]) }), c.addEventListener("click", convertExcelToPDF) } function handleJPGFiles(e) { let t = Array.from(e).filter(e => "image/jpeg" === e.type || "image/jpg" === e.type || "image/png" === e.type); 0 !== t.length && (jpgFiles = [...jpgFiles, ...t], renderJPGList()) } function renderJPGList() {
    let e = document.getElementById("jpg-file-list"), t = document.getElementById("jpg-convert-btn"); e.innerHTML = "", jpgFiles.forEach((t, a) => {
        let n = document.createElement("div"); n.className = "file-item", n.draggable = !0, n.dataset.index = a; let i = document.createElement("div"); i.className = "file-preview"; let r = document.createElement("img"); r.src = URL.createObjectURL(t), r.style.width = "100%", r.style.height = "100%", r.style.objectFit = "contain", i.appendChild(r), n.innerHTML = `
            <div class="file-info">${t.name}</div>
            <div class="file-controls">
                <button onclick="moveJPG(${a}, -1)" title="Move Up" class="btn-icon">
                    <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="18 15 12 9 6 15"></polyline></svg>
                </button>
                <button onclick="moveJPG(${a}, 1)" title="Move Down" class="btn-icon">
                    <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                </button>
                <div class="separator"></div>
                <button class="btn-icon remove" onclick="removeJPG(${a})">
                    <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                </button>
            </div>
        `, n.insertBefore(i, n.firstChild), n.addEventListener("dragstart", () => { n.classList.add("dragging") }), n.addEventListener("dragend", () => { n.classList.remove("dragging"), updateJPGFilesOrder() }), e.appendChild(n)
    }); let a = document.getElementById("jpg-help-text"); jpgFiles.length > 0 ? (document.getElementById("jpg-upload-area").classList.add("hidden"), a.textContent = "Tip: Drag and drop files to reorder them. The top file will be the first page in the merged PDF.", a.classList.remove("hidden"), t.disabled = !1) : (document.getElementById("jpg-upload-area").classList.remove("hidden"), a.classList.add("hidden"), t.disabled = !0)
} function updateJPGFilesOrder() { let e = document.getElementById("jpg-file-list"), t = e.querySelectorAll(".file-item"), a = [...jpgFiles]; jpgFiles = [], t.forEach(e => { let t = parseInt(e.dataset.index); jpgFiles.push(a[t]) }), renderJPGList() } async function convertJPGtoPDF() { if (0 === jpgFiles.length) return; let t = document.getElementById("jpg-convert-btn"); try { t.textContent = "Converting...", t.disabled = !0; let a = await e.create(); for (let n of jpgFiles) { let i = await n.arrayBuffer(), r; r = "image/png" === n.type ? await a.embedPng(i) : await a.embedJpg(i); let l = a.addPage([r.width, r.height]); l.drawImage(r, { x: 0, y: 0, width: r.width, height: r.height }) } let o = await a.save(); triggerDownloadAnimation(t), downloadFile(o, "images-converted.pdf") } catch (s) { console.error(s), showNotification("Error converting images.", "error") } finally { t.textContent = "Convert to PDF", t.disabled = !1 } } function handleWordFile(e) {
    if (!e || !e.name.endsWith(".docx")) return; wordFile = e; let t = document.getElementById("word-file-info"), a = document.getElementById("word-convert-btn"), n = document.getElementById("word-upload-area"); n.classList.add("hidden"), t.innerHTML = `
        <div class="file-item" style="margin:0; border:var(--primary-color) 1px solid;">
            <div class="file-info">${e.name}</div>
            <div class="file-controls">
                <button class="btn-icon remove" onclick="removeWordFile()" title="Remove">
                    <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                </button>
            </div>
        </div>
    `, t.classList.remove("hidden"), a.disabled = !1
} async function convertWordToPDF() {
    if (!wordFile) return; let e = document.getElementById("word-convert-btn"); try {
        e.textContent = "Preparing...", e.disabled = !0; let t = await wordFile.arrayBuffer(), a = await mammoth.convertToHtml({ arrayBuffer: t }), n = a.value, i = a.messages; if (i.length > 0 && console.warn("Mammoth warnings:", i), !n) throw Error("No content extracted from Word file."); let r = document.createElement("iframe"); r.style.position = "absolute", r.style.width = "0", r.style.height = "0", r.style.border = "none", document.body.appendChild(r); let l = r.contentWindow.document; l.open(), l.write(`
            <html>
            <head>
                <title>${wordFile.name.replace(".docx", "")}</title>
                <style>
                    body {
                        font-family: Arial, sans-serif;
                        line-height: 1.6;
                        color: #000;
                        margin: 0;
                        padding: 0;
                    }
                    @page {
                        size: auto;
                        margin: 0mm;
                    }
                    @media print {
                        body { margin: 0 !important; padding: 0 !important; }
                        table.layout-table { width: 100%; border: none; border-spacing: 0; border-collapse: collapse; }
                        thead { display: table-header-group; }
                        tfoot { display: table-footer-group; }
                        .header-space, .footer-space { height: 20mm; }
                        tfoot { display: table-footer-group; }
                        .header-space, .footer-space { height: 20mm; }
                        .content-wrapper { padding: 0 20mm; }
                        /* Ensure layout table cells have no border */
                        table.layout-table td { border: none !important; padding: 0 !important; }
                    }
                    img { max-width: 100%; height: auto; }
                    table { border-collapse: collapse; width: 100%; margin-bottom: 1em; }
                    td, th { border: 1px solid #ddd; padding: 8px; }
                </style>
            </head>
            <body>
                <table class="layout-table">
                    <thead>
                        <tr><td><div class="header-space">&nbsp;</div></td></tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>
                                <div class="content-wrapper">
                                    ${n}
                                </div>
                            </td>
                        </tr>
                    </tbody>
                    <tfoot>
                        <tr><td><div class="footer-space">&nbsp;</div></td></tr>
                    </tfoot>
                </table>
                <script>
                    window.onload = function() {
                        setTimeout(function() {
                            window.print();
                            window.parent.document.body.removeChild(window.frameElement);
                        }, 500);
                    };
                </script>
            </body>
            </html>
        `), l.close(), showNotification('Print dialog opened. Please select "Save as PDF".', "success")
    } catch (o) { console.error("Word to PDF Error:", o), showNotification("Error processing Word file.", "error") } finally { e.textContent = "Convert to PDF", e.disabled = !1 }
} function handleExcelFile(e) {
    if (!e || !e.name.endsWith(".xlsx") && !e.name.endsWith(".xls")) return; excelFile = e; let t = document.getElementById("excel-file-info"), a = document.getElementById("excel-convert-btn"), n = document.getElementById("excel-upload-area"); n.classList.add("hidden"), t.innerHTML = `
        <div class="file-item" style="margin:0; border:var(--primary-color) 1px solid;">
            <div class="file-info">${e.name}</div>
            <div class="file-controls">
                <button class="btn-icon remove" onclick="removeExcelFile()" title="Remove">
                    <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                </button>
            </div>
        </div>
    `, t.classList.remove("hidden"), a.disabled = !1
} async function convertExcelToPDF() {
    if (!excelFile) return; let e = document.getElementById("excel-convert-btn"); try {
        e.textContent = "Preparing...", e.disabled = !0; let t = await excelFile.arrayBuffer(), a = XLSX.read(t), n = a.SheetNames[0], i = a.Sheets[n], r = XLSX.utils.sheet_to_html(i), l = document.createElement("iframe"); l.style.position = "absolute", l.style.width = "0", l.style.height = "0", l.style.border = "none", document.body.appendChild(l); let o = l.contentWindow.document; o.open(), o.write(`
            <html>
            <head>
                <title>${excelFile.name.replace(/\.xls[x]?$/, "")}</title>
                <style>
                    body {
                        font-family: Arial, sans-serif;
                        line-height: 1.6;
                        color: #000;
                        margin: 0;
                        padding: 0;
                    }
                    @page {
                        size: auto;
                        margin: 0mm;
                    }
                    @media print {
                        body { margin: 0 !important; padding: 0 !important; }
                        table.layout-table { width: 100%; border: none; border-spacing: 0; border-collapse: collapse; }
                        thead { display: table-header-group; }
                        tfoot { display: table-footer-group; }
                        .header-space, .footer-space { height: 20mm; }
                        tfoot { display: table-footer-group; }
                        .header-space, .footer-space { height: 20mm; }
                        .content-wrapper { padding: 0 20mm; }
                        /* Ensure layout table cells have no border */
                        table.layout-table td { border: none !important; padding: 0 !important; }
                    }
                    /* Excel Content Styles */
                    table { 
                        border-collapse: collapse; 
                        width: 100%; 
                        margin-bottom: 1em; 
                    }
                    td, th { 
                        border: 1px solid #ddd; 
                        padding: 8px; 
                        text-align: left;
                    }
                </style>
            </head>
            <body>
                <table class="layout-table">
                    <thead>
                        <tr><td><div class="header-space">&nbsp;</div></td></tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>
                                <div class="content-wrapper">
                                    ${r}
                                </div>
                            </td>
                        </tr>
                    </tbody>
                    <tfoot>
                        <tr><td><div class="footer-space">&nbsp;</div></td></tr>
                    </tfoot>
                </table>
                <script>
                    window.onload = function() {
                        setTimeout(function() {
                            window.print();
                            window.parent.document.body.removeChild(window.frameElement);
                        }, 500);
                    };
                </script>
            </body>
            </html>
        `), o.close(), showNotification('Print dialog opened. Please select "Save as PDF".', "success")
    } catch (s) { console.error("Excel to PDF Error:", s), showNotification("Error processing Excel file.", "error") } finally { e.textContent = "Convert to PDF", e.disabled = !1 }
} window.moveJPG = (e, t) => { if (0 === e && -1 === t || e === jpgFiles.length - 1 && 1 === t) return; let a = jpgFiles[e]; jpgFiles[e] = jpgFiles[e + t], jpgFiles[e + t] = a, renderJPGList() }, window.removeJPG = e => { jpgFiles.splice(e, 1), renderJPGList() }, window.removeWordFile = () => { wordFile = null; let e = document.getElementById("word-file-info"), t = document.getElementById("word-convert-btn"), a = document.getElementById("word-upload-area"), n = document.getElementById("word-file-input"); n.value = "", e.classList.add("hidden"), e.innerHTML = "", a.classList.remove("hidden"), t.disabled = !0 }, window.removeExcelFile = () => { excelFile = null; let e = document.getElementById("excel-file-info"), t = document.getElementById("excel-convert-btn"), a = document.getElementById("excel-upload-area"), n = document.getElementById("excel-file-input"); n.value = "", e.classList.add("hidden"), e.innerHTML = "", a.classList.remove("hidden"), t.disabled = !0 }; let editFile = null, originalEditFile = null, fabricCanvas = null, editPdfDoc = null, editPdfBytes = null, currentEditTool = "select", editZoom = 1, editPanX = 0, editPanY = 0, isPanning = !1, startPanX = 0, startPanY = 0, loadedPdf = null, totalEditPages = 0, editPageAnnotations = {}, currentEditPageIndex = 0; function setupEditEvents() { let e = document.getElementById("edit-upload-area"), t = document.getElementById("edit-file-input"), a = document.getElementById("save-pdf-btn"), n = document.getElementById("clear-pdf-btn"), i = document.getElementById("tool-color"); setupZoomPan(), e.addEventListener("dragover", t => { t.preventDefault(), e.classList.add("dragover") }), e.addEventListener("dragleave", () => e.classList.remove("dragover")), e.addEventListener("drop", t => { t.preventDefault(), e.classList.remove("dragover"), handleEditFile(t.dataTransfer.files[0]) }), t.addEventListener("change", e => handleEditFile(e.target.files[0])), document.getElementById("tool-select").addEventListener("click", () => setEditTool("select")), document.getElementById("tool-text").addEventListener("click", () => setEditTool("text")), setEditTool("select"), document.getElementById("tool-draw").addEventListener("click", () => setEditTool("draw")), document.getElementById("tool-rect").addEventListener("click", () => addShape("rect")), document.getElementById("tool-circle").addEventListener("click", () => addShape("circle")), document.getElementById("tool-line").addEventListener("click", () => { setEditTool("draw"), addEditLine() }), document.getElementById("edit-image-input").addEventListener("change", e => { e.target.files && e.target.files[0] && (addEditImage(e.target.files[0]), e.target.value = "") }), document.getElementById("tool-delete").addEventListener("click", deleteSelectedObject), i.addEventListener("input", e => { if (!fabricCanvas) return; let t = e.target.value, a = fabricCanvas.getActiveObject(); a && ("i-text" === a.type || "text" === a.type ? a.isEditing ? a.setSelectionStyles({ fill: t }) : a.set("fill", t) : "rect" === a.type || "circle" === a.type || "line" === a.type ? a.set("stroke", t) : "path" === a.type && a.set("stroke", t), fabricCanvas.requestRenderAll()), fabricCanvas.freeDrawingBrush && (fabricCanvas.freeDrawingBrush.color = t) }), document.getElementById("font-family").addEventListener("change", function () { if (!fabricCanvas) return; let e = fabricCanvas.getActiveObject(); e && ("i-text" === e.type || "text" === e.type) && (e.isEditing ? e.setSelectionStyles({ fontFamily: this.value }) : e.set("fontFamily", this.value), fabricCanvas.requestRenderAll()) }), document.getElementById("font-size").addEventListener("change", function () { if (!fabricCanvas) return; let e = fabricCanvas.getActiveObject(); if (e && ("i-text" === e.type || "text" === e.type)) { let t = parseInt(this.value, 10); e.isEditing ? e.setSelectionStyles({ fontSize: t }) : e.set("fontSize", t), fabricCanvas.requestRenderAll() } }), document.getElementById("text-bold").addEventListener("click", function () { if (!fabricCanvas) return; let e = fabricCanvas.getActiveObject(); if (e && ("i-text" === e.type || "text" === e.type)) { let t = !1; if (e.isEditing) { let a = e.getSelectionStyles(), n = a[0] && a[0].fontWeight || e.fontWeight; t = "bold" === n, e.setSelectionStyles({ fontWeight: t ? "normal" : "bold" }) } else t = "bold" === e.fontWeight, e.set("fontWeight", t ? "normal" : "bold"); fabricCanvas.requestRenderAll(), this.classList.toggle("active", !t) } }), document.getElementById("text-italic").addEventListener("click", function () { if (!fabricCanvas) return; let e = fabricCanvas.getActiveObject(); if (e && ("i-text" === e.type || "text" === e.type)) { let t = !1; if (e.isEditing) { let a = e.getSelectionStyles(), n = a[0] && a[0].fontStyle || e.fontStyle; t = "italic" === n, e.setSelectionStyles({ fontStyle: t ? "normal" : "italic" }) } else t = "italic" === e.fontStyle, e.set("fontStyle", t ? "normal" : "italic"); fabricCanvas.requestRenderAll(), this.classList.toggle("active", !t) } }), document.getElementById("text-underline").addEventListener("click", function () { if (!fabricCanvas) return; let e = fabricCanvas.getActiveObject(); if (e && ("i-text" === e.type || "text" === e.type)) { let t = !1; if (e.isEditing) { let a = e.getSelectionStyles(), n = a[0] && a[0].underline || e.underline; t = !!n, e.setSelectionStyles({ underline: !t }) } else t = !!e.underline, e.set("underline", !t); fabricCanvas.requestRenderAll(), this.classList.toggle("active", !t) } }); let r = ["left", "center", "right"]; r.forEach(e => { document.getElementById(`text-align-${e}`).addEventListener("click", function () { if (!fabricCanvas) return; let t = fabricCanvas.getActiveObject(); t && ("i-text" === t.type || "text" === t.type) && (t.set("textAlign", e), fabricCanvas.requestRenderAll(), r.forEach(e => document.getElementById(`text-align-${e}`).classList.remove("active")), this.classList.add("active")) }) }); let l = document.getElementById("tool-emoji"), o = document.querySelector(".emoji-content"); l.addEventListener("click", e => { e.stopPropagation(), o.classList.toggle("hidden") }), document.querySelectorAll(".emoji-content span").forEach(e => { e.addEventListener("click", e => { let t = e.target.getAttribute("data-emoji"); addEditEmoji(t), o.classList.add("hidden") }) }), document.addEventListener("click", e => { !l || l.contains(e.target) || o.contains(e.target) || o.classList.add("hidden") }); let s = document.getElementById("confirmation-modal"), d = document.getElementById("modal-cancel-btn"), c = document.getElementById("modal-confirm-btn"); window.showConfirmModal = function (e) { onConfirmAction = e, s.classList.remove("hidden") }, window.hideConfirmModal = function () { s.classList.add("hidden"), onConfirmAction = null }, d.addEventListener("click", window.hideConfirmModal), c.addEventListener("click", () => { onConfirmAction && onConfirmAction(), window.hideConfirmModal() }), a.addEventListener("click", saveEditedPdf), n.addEventListener("click", () => { showConfirmModal(clearAnnotations) }), setupWatermarkEvents() } async function handleEditFile(e, t = !1) { if (e && "application/pdf" === e.type) { if ("undefined" == typeof fabric) { showNotification("Fabric.js library not loaded. Please check your internet connection.", "error"); return } t || (originalEditFile = e), editFile = e, document.getElementById("edit-upload-area").classList.add("hidden"), document.getElementById("editor-container").classList.remove("hidden"), fabricCanvas && (fabricCanvas.dispose(), fabricCanvas = null), loadedPdf = null, totalEditPages = 0, editPageAnnotations = {}, currentEditPageIndex = 0, document.getElementById("edit-page-list").innerHTML = ""; try { let a = await e.arrayBuffer(); editPdfBytes = a; let n = pdfjsLib.getDocument(a); totalEditPages = (loadedPdf = await n.promise).numPages, renderEditPageList(), loadEditPage(1); let i = document.querySelector('input[name="edit-feature-mode"]:checked').value, r = document.getElementById("main-editor-toolbar"); r && ("edit" === i ? r.classList.remove("hidden") : r.classList.add("hidden")) } catch (l) { console.error("Editor Initialization Error:", l), showNotification("Error loading PDF for editing.", "error"), document.getElementById("edit-upload-area").classList.remove("hidden"), document.getElementById("editor-container").classList.add("hidden") } } } async function renderEditPageList() { let e = document.getElementById("edit-page-list"); e.innerHTML = ""; for (let t = 1; t <= totalEditPages; t++) { let a = document.createElement("div"); a.className = `page-thumbnail ${1 === t ? "active" : ""}`, a.id = `edit-thumb-${t}`, a.onclick = () => switchEditPage(t); let n = document.createElement("canvas"); a.appendChild(n); let i = document.createElement("span"); i.className = "page-number", i.innerText = t, a.appendChild(i), e.appendChild(a), renderThumbnailToCanvas(t, n) } } async function renderThumbnailToCanvas(e, t) { if (loadedPdf) try { let a = await loadedPdf.getPage(e), n = a.getViewport({ scale: .3 }); t.width = n.width, t.height = n.height; let i = t.getContext("2d"); await a.render({ canvasContext: i, viewport: n }).promise } catch (r) { console.warn(`Error rendering thumbnail for page ${e}`, r) } } async function switchEditPage(e) { if (currentEditPageIndex !== e - 1) { if (fabricCanvas) { let t = fabricCanvas.toJSON(); delete t.backgroundImage, editPageAnnotations[currentEditPageIndex] = t } await loadEditPage(e) } } async function loadEditPage(e) { let t = e - 1; currentEditPageIndex = t, document.querySelectorAll(".page-sidebar .page-thumbnail").forEach(e => e.classList.remove("active")); let a = document.getElementById(`edit-thumb-${e}`); a && a.classList.add("active"); let n = document.getElementById("pdf-editor-canvas"); try { let i = await loadedPdf.getPage(e), r = document.getElementById("editor-main-area"), l = r ? r.clientWidth - 20 : window.innerWidth - 30, o = i.getViewport({ scale: 1 }), s = 1.5; l < 1.5 * o.width && (s = l / o.width), setZoom(s); let d = i.getViewport({ scale: s }); fabricCanvas ? (console.log("Reusing existing Fabric Canvas"), fabricCanvas.setDimensions({ width: d.width, height: d.height }), fabricCanvas.setViewportTransform([1, 0, 0, 1, 0, 0])) : (n.width = d.width, n.height = d.height, (fabricCanvas = new fabric.Canvas("pdf-editor-canvas", { width: d.width, height: d.height, isDrawingMode: !1, selection: !0 })).freeDrawingBrush = new fabric.PencilBrush(fabricCanvas), fabricCanvas.freeDrawingBrush.width = 3, setupFabricEvents()); let c = document.createElement("canvas"); c.width = d.width, c.height = d.height; let g = c.getContext("2d"); await i.render({ canvasContext: g, viewport: d }).promise; let m = c.toDataURL("image/png"), p = () => { fabricCanvas.setBackgroundImage(m, () => { fabricCanvas.renderAll(); let e = document.getElementById("tool-color"); e && fabricCanvas.freeDrawingBrush && (fabricCanvas.freeDrawingBrush.color = e.value) }, { originX: "left", originY: "top" }) }; editPageAnnotations[t] ? fabricCanvas.loadFromJSON(editPageAnnotations[t], () => { p() }) : (fabricCanvas.clear(), p()) } catch (f) { console.error("Error loading page into editor:", f), showNotification("Error loading page into editor:", "warning") } } function setupFabricEvents() { fabricCanvas.on("selection:created", handleSelection), fabricCanvas.on("selection:updated", handleSelection), fabricCanvas.on("selection:cleared", () => { document.getElementById("text-properties-toolbar").classList.add("hidden") }) } function setEditTool(e) { currentEditTool = e, document.querySelectorAll(".editor-toolbar .tool-btn").forEach(e => e.classList.remove("active")), "hand" === e ? (fabricCanvas && (fabricCanvas.isDrawingMode = !1, fabricCanvas.selection = !1, fabricCanvas.defaultCursor = "grab", fabricCanvas.hoverCursor = "grab", fabricCanvas.forEachObject(e => e.selectable = !1), fabricCanvas.discardActiveObject(), fabricCanvas.requestRenderAll()), document.getElementById("editor-viewport").classList.add("hand-mode"), document.getElementById("tool-hand").classList.add("active")) : (document.getElementById("editor-viewport").classList.remove("hand-mode"), fabricCanvas && (fabricCanvas.selection = !0, fabricCanvas.defaultCursor = "default", fabricCanvas.hoverCursor = "move", fabricCanvas.forEachObject(e => e.selectable = !0))), "select" === e ? (document.getElementById("tool-select").classList.add("active"), fabricCanvas && (fabricCanvas.isDrawingMode = !1, fabricCanvas.selection = !0, fabricCanvas.defaultCursor = "default", fabricCanvas.forEachObject(e => e.selectable = !0))) : "draw" === e ? (document.getElementById("tool-draw").classList.add("active"), fabricCanvas && (fabricCanvas.isDrawingMode = !0, fabricCanvas.defaultCursor = "crosshair", fabricCanvas.discardActiveObject(), fabricCanvas.requestRenderAll())) : "text" === e && (document.getElementById("tool-text").classList.add("active"), fabricCanvas && (fabricCanvas.isDrawingMode = !1, addText()), setEditTool("select")) } function addText() { if (!fabricCanvas) return; let e = new fabric.IText("Type here", { left: 100, top: 200, fontFamily: "Arial", fill: document.getElementById("tool-color").value, fontSize: 20 }); fabricCanvas.add(e), fabricCanvas.setActiveObject(e) } function addShape(e) { if (!fabricCanvas) return; let t = document.getElementById("tool-color").value, a; "rect" === e ? a = new fabric.Rect({ left: 150, top: 150, fill: "transparent", stroke: t, strokeWidth: 3, width: 100, height: 60 }) : "circle" === e && (a = new fabric.Circle({ left: 200, top: 200, fill: "transparent", stroke: t, strokeWidth: 3, radius: 40 })), a && (fabricCanvas.add(a), fabricCanvas.setActiveObject(a), setEditTool("select")) } function addEditLine() { if (!fabricCanvas) return; let e = document.getElementById("tool-color").value, t = new fabric.Line([50, 50, 200, 50], { stroke: e, strokeWidth: 3, selectable: !0 }); fabricCanvas.add(t), fabricCanvas.setActiveObject(t), setEditTool("select") } function addEditEmoji(e) { if (!fabricCanvas) return; let t = new fabric.IText(e, { left: 200, top: 200, fontSize: 40, selectable: !0 }); fabricCanvas.add(t), fabricCanvas.setActiveObject(t), setEditTool("select") } function addEditImage(e) { if (!fabricCanvas) return; let t = new FileReader; t.onload = function (e) { fabric.Image.fromURL(e.target.result, function (e) { e.scaleToWidth(150), fabricCanvas.add(e), fabricCanvas.centerObject(e), fabricCanvas.setActiveObject(e), setEditTool("select") }) }, t.readAsDataURL(e) } function deleteSelectedObject() { if (!fabricCanvas) return; let e = fabricCanvas.getActiveObjects(); e.length && (fabricCanvas.discardActiveObject(), e.forEach(function (e) { fabricCanvas.remove(e) })) } function clearAnnotations() { fabricCanvas && (fabricCanvas.getObjects().forEach(e => { fabricCanvas.remove(e) }), editPageAnnotations[currentEditPageIndex] && (editPageAnnotations[currentEditPageIndex] = { objects: [] })) } function handleSelection(e) { let t = document.querySelector('input[name="edit-feature-mode"]:checked').value; if ("edit" !== t) return; let a = e.selected[0]; if (!a) return; let n = document.getElementById("tool-color"); "i-text" === a.type || "text" === a.type ? n.value = a.fill : a.stroke && (n.value = a.stroke); let i = document.getElementById("text-properties-toolbar"); if ("i-text" === a.type || "text" === a.type) { i.classList.remove("hidden"); let r = document.getElementById("font-family"); r && (r.value = a.fontFamily || "Arial"); let l = document.getElementById("font-size"); l && (l.value = a.fontSize || 20); let o = document.getElementById("text-bold"); o && o.classList.toggle("active", "bold" === a.fontWeight); let s = document.getElementById("text-italic"); s && s.classList.toggle("active", "italic" === a.fontStyle); let d = document.getElementById("text-underline"); d && d.classList.toggle("active", !!a.underline), ["left", "center", "right"].forEach(e => { let t = document.getElementById(`text-align-${e}`); t && (a.textAlign === e ? t.classList.add("active") : t.classList.remove("active")) }) } else i.classList.add("hidden") } async function saveEditedPdf() { try { let t = document.getElementById("save-pdf-btn"); if (t.textContent = "Saving...", t.disabled = !0, fabricCanvas) { let a = fabricCanvas.toJSON(); delete a.backgroundImage, editPageAnnotations[currentEditPageIndex] = a } let n = await editFile.arrayBuffer(), i = await e.load(n), r = i.getPages(), l = document.createElement("canvas"); for (let o = 0; o < r.length; o++)if (editPageAnnotations[o] && editPageAnnotations[o].objects.length > 0) { let s = r[o], { width: d, height: c } = s.getSize(); l.width = 2 * d, l.height = 2 * c; let g = new fabric.StaticCanvas(null, { width: 2 * d, height: 2 * c }); await new Promise(e => { g.loadFromJSON(editPageAnnotations[o], e) }); let m = 2 / 1.5, p = g.getObjects(); p.forEach(e => { e.scaleX *= m, e.scaleY *= m, e.left *= m, e.top *= m, e.setCoords() }), g.renderAll(); let f = g.toDataURL({ format: "png" }), v = await i.embedPng(f); s.drawImage(v, { x: 0, y: 0, width: d, height: c }), g.dispose() } let u = await i.save(); triggerDownloadAnimation(t), downloadFile(u, "edited.pdf") } catch (h) { console.error(h), showNotification("Error saving PDF", "error") } finally { let y = document.getElementById("save-pdf-btn"); y.textContent = "Save & Download PDF", y.disabled = !1 } } window.originalWarn || (window.originalWarn = console.warn), console.warn = function (...e) { e[0] && "string" == typeof e[0] && e[0].includes("CanvasTextBaseline") || window.originalWarn.apply(console, e) }; let watermarkObject = null, watermarkMode = "text"; function setupWatermarkEvents() { let e = document.getElementsByName("edit-feature-mode"); e.forEach(e => { e.addEventListener("change", e => { let t = e.target.value, a = document.getElementById("edit-feature-content"), n = document.getElementById("watermark-controls"), i = document.getElementById("rotate-pdf-section"), r = document.getElementById("page-number-controls"); i && i.classList.add("hidden"), n && n.classList.add("hidden"), r && r.classList.add("hidden"), "edit" === t ? a && a.classList.remove("hidden") : "watermark" === t ? (a && a.classList.remove("hidden"), n && n.classList.remove("hidden"), initWatermark()) : "rotate" === t ? (a && a.classList.add("hidden"), i && i.classList.remove("hidden")) : "page-numbers" === t && (a && a.classList.remove("hidden"), r && r.classList.remove("hidden"), initPageNumbers()) }) }); let t = document.getElementById("wm-type-text"), a = document.getElementById("wm-type-image"); t && t.addEventListener("click", () => toggleWatermarkType("text")), a && a.addEventListener("click", () => toggleWatermarkType("image")); let n = document.getElementById("wm-text-input"), i = document.getElementById("wm-font-family"), r = document.getElementById("wm-font-size"), l = document.getElementById("wm-color"); n && n.addEventListener("input", updateWatermark), i && i.addEventListener("change", updateWatermark), r && r.addEventListener("input", updateWatermark), l && l.addEventListener("input", updateWatermark); let o = document.getElementById("wm-opacity"); o && o.addEventListener("input", e => { let t = document.getElementById("wm-opacity-val"); t && (t.textContent = e.target.value + "%"), updateWatermark() }); let s = document.getElementById("wm-rotation"); s && s.addEventListener("input", e => { let t = document.getElementById("wm-rotation-val"); t && (t.textContent = e.target.value + "\xb0"), updateWatermark() }); let d = document.getElementById("wm-scale"); d && d.addEventListener("input", e => { let t = document.getElementById("wm-scale-val"); t && (t.textContent = e.target.value + "%"), updateWatermark() }), document.querySelectorAll(".wm-position-grid button").forEach(e => { e.addEventListener("click", e => { document.querySelectorAll(".wm-position-grid button").forEach(e => e.classList.remove("active")), e.target.classList.add("active"), updateWatermarkPosition(e.target.dataset.pos) }) }); let c = document.getElementById("wm-image-input"); c && c.addEventListener("change", e => { let t = e.target.files[0]; if (t) { let a = new FileReader; a.onload = e => { updateWatermarkImage(e.target.result) }, a.readAsDataURL(t) } }); let g = document.getElementById("apply-watermark-btn"); g && g.addEventListener("click", saveWatermarkedPDF) } function initWatermark() { fabricCanvas && toggleWatermarkType("text") } function clearWatermark() { watermarkObject && fabricCanvas && (fabricCanvas.remove(watermarkObject), watermarkObject = null, fabricCanvas.requestRenderAll()) } function toggleWatermarkType(e) { watermarkMode = e; let t = document.getElementById("wm-text-settings"), a = document.getElementById("wm-image-settings"), n = document.getElementById("wm-type-text"), i = document.getElementById("wm-type-image"); "text" === e ? (t && t.classList.remove("hidden"), a && a.classList.add("hidden"), n && n.classList.add("active"), i && i.classList.remove("active"), updateWatermark()) : (t && t.classList.add("hidden"), a && a.classList.remove("hidden"), n && n.classList.remove("active"), i && i.classList.add("active"), watermarkObject && "image" === watermarkObject.type || clearWatermark()) } function updateWatermark() { if (!fabricCanvas) return; let e = document.getElementById("wm-text-input"); if (!e) return; let t = e.value, a = document.getElementById("wm-font-family").value, n = parseInt(document.getElementById("wm-font-size").value), i = document.getElementById("wm-color").value, r = parseInt(document.getElementById("wm-opacity").value) / 100, l = parseInt(document.getElementById("wm-rotation").value); if (watermarkObject && "image" !== watermarkObject.type && "text" === watermarkMode && fabricCanvas.remove(watermarkObject), "text" === watermarkMode && watermarkObject && "image" === watermarkObject.type && (fabricCanvas.remove(watermarkObject), watermarkObject = null), "text" === watermarkMode) { watermarkObject = new fabric.Text(t, { fontFamily: a, fontSize: n, fill: i, opacity: r, angle: l, selectable: !1, originX: "center", originY: "center" }), fabricCanvas.add(watermarkObject); let o = document.querySelector(".wm-position-grid button.active"); o ? updateWatermarkPosition(o.dataset.pos) : fabricCanvas.centerObject(watermarkObject) } else if ("image" === watermarkMode && watermarkObject && "image" === watermarkObject.type) { watermarkObject.set({ opacity: r, angle: l }); let s = document.getElementById("wm-scale").value, d = parseInt(s) / 100; watermarkObject.scale(d), fabricCanvas.requestRenderAll(); let c = document.querySelector(".wm-position-grid button.active"); c && updateWatermarkPosition(c.dataset.pos) } } function updateWatermarkImage(e) { fabricCanvas && fabric.Image.fromURL(e, e => { watermarkObject && fabricCanvas.remove(watermarkObject), (watermarkObject = e).set({ originX: "center", originY: "center", selectable: !1 }), fabricCanvas.add(watermarkObject), updateWatermark() }) } function updateWatermarkPosition(e) { if (!watermarkObject || !fabricCanvas) return; let t = fabricCanvas.getWidth(), a = fabricCanvas.getHeight(), n = t / 2, i = a / 2; switch (e) { case "tl": n = 40, i = 40, watermarkObject.set({ originX: "left", originY: "top" }); break; case "tc": n = t / 2, i = 40, watermarkObject.set({ originX: "center", originY: "top" }); break; case "tr": n = t - 40, i = 40, watermarkObject.set({ originX: "right", originY: "top" }); break; case "cl": n = 40, i = a / 2, watermarkObject.set({ originX: "left", originY: "center" }); break; case "cc": n = t / 2, i = a / 2, watermarkObject.set({ originX: "center", originY: "center" }); break; case "cr": n = t - 40, i = a / 2, watermarkObject.set({ originX: "right", originY: "center" }); break; case "bl": n = 40, i = a - 40, watermarkObject.set({ originX: "left", originY: "bottom" }); break; case "bc": n = t / 2, i = a - 40, watermarkObject.set({ originX: "center", originY: "bottom" }); break; case "br": n = t - 40, i = a - 40, watermarkObject.set({ originX: "right", originY: "bottom" }) }watermarkObject.set({ left: n, top: i }), watermarkObject.setCoords(), fabricCanvas.requestRenderAll() } async function saveWatermarkedPDF() { if (!editFile) { showNotification("No PDF file loaded!", "error"); return } try { let e = document.getElementById("apply-watermark-btn"); e.textContent = "Processing...", e.disabled = !0; let t = await editFile.arrayBuffer(), a = await PDFLib.PDFDocument.load(t), n = a.getPages(); fabricCanvas.backgroundImage; let i = fabricCanvas.getObjects(); i.forEach(e => { e !== watermarkObject && (e.visible = !1) }), fabricCanvas.backgroundImage && (fabricCanvas.backgroundImage.opacity = 0), fabricCanvas.renderAll(); let r = fabricCanvas.toDataURL({ format: "png", multiplier: 2 }); fabricCanvas.backgroundImage && (fabricCanvas.backgroundImage.opacity = 1), i.forEach(e => e.visible = !0), fabricCanvas.renderAll(); let l = await a.embedPng(r); l.scale(.5), n.forEach(e => { e.drawImage(l, { x: 0, y: 0, width: e.getWidth(), height: e.getHeight() }) }); let o = await a.save(); downloadFile(o, "watermarked_document.pdf", "application/pdf"), showNotification("Watermark added to all pages!", "success") } catch (s) { console.error("Save Watermark Error:", s), showNotification("Failed to save watermark.", "error") } finally { let d = document.getElementById("apply-watermark-btn"); d.textContent = "Add Watermark & Download", d.disabled = !1 } } function setupWelcomePopup() { let e = document.getElementById("welcome-popup"), t = document.getElementById("popup-close-btn"), a = document.getElementById("popup-action-btn"), n = document.getElementById("fireworks-canvas"); if (!e || !n) return; let i = n.getContext("2d"), r = [], l = null; window.addEventListener("load", () => { setTimeout(() => { e.classList.remove("hidden"), e.offsetWidth, e.classList.add("show"), document.body.classList.add("modal-open") }, 1e3) }); let o = () => { e.classList.remove("show"), document.body.classList.remove("modal-open"), setTimeout(() => { e.classList.add("hidden"), setTimeout(() => { cancelAnimationFrame(l), i.clearRect(0, 0, n.width, n.height), r = [] }, 2e3) }, 400) }; function s() { n.width = window.innerWidth, n.height = window.innerHeight } t && t.addEventListener("click", o), e.addEventListener("click", t => { t.target === e && o() }), window.addEventListener("resize", s), s(); class d { constructor(e, t, a) { this.x = e, this.y = t, this.color = a; let n = Math.random() * Math.PI * 2, i = 8 * Math.random() + 2; this.vx = Math.cos(n) * i, this.vy = Math.sin(n) * i, this.friction = .96, this.gravity = .15, this.alpha = 1, this.decay = .015 * Math.random() + .005 } draw() { i.save(), i.globalAlpha = this.alpha, i.beginPath(), i.arc(this.x, this.y, 2, 0, 2 * Math.PI), i.fillStyle = this.color, i.fill(), i.shadowBlur = 10, i.shadowColor = this.color, i.fill(), i.restore() } update() { this.vx *= this.friction, this.vy *= this.friction, this.vy += this.gravity, this.x += this.vx, this.y += this.vy, this.alpha -= this.decay } } function c(e, t) { let a = ["#FF1493", "#00BFFF", "#32CD32", "#FFD700", "#9400D3", "#FF4500"]; for (let n = 0; n < 150; n++) { let i = a[Math.floor(Math.random() * a.length)]; r.push(new d(e, t, i)) } } a && a.addEventListener("click", e => { let t = document.querySelector(".popup-box"), a, s; if (t) { let d = t.getBoundingClientRect(); a = d.left + d.width / 2, s = d.top } else a = window.innerWidth / 2, s = window.innerHeight / 2; l && 0 !== r.length || function e() { l = requestAnimationFrame(e), i.globalCompositeOperation = "destination-out", i.fillStyle = "rgba(0, 0, 0, 0.1)", i.fillRect(0, 0, n.width, n.height), i.globalCompositeOperation = "source-over", r.forEach((e, t) => { e.alpha > 0 ? (e.update(), e.draw()) : r.splice(t, 1) }) }(), c(a, s), setTimeout(() => c(a + (Math.random() - .5) * 100, s + (Math.random() - .5) * 100), 100), setTimeout(() => c(a + (Math.random() - .5) * 100, s + (Math.random() - .5) * 100), 200), setTimeout(() => c(a + (Math.random() - .5) * 100, s + (Math.random() - .5) * 100), 300), o() }) } function setupSecurityEvents() { let e = document.getElementsByName("security-mode"); e.forEach(e => { e.addEventListener("change", e => { let t = e.target.value; document.getElementById("protect-pdf-section").classList.add("hidden"), document.getElementById("sign-pdf-section").classList.add("hidden"), "protect-pdf" === t ? document.getElementById("protect-pdf-section").classList.remove("hidden") : "sign-pdf" === t && document.getElementById("sign-pdf-section").classList.remove("hidden") }) }), setupProtectPDFEvents(), setupSignPDFEvents() } let protectFile = null, signFile = null, signCanvas = null, signaturePadContext = null, isSigning = !1, currentSignPage = 1, totalSignPages = 0, signPageAnnotations = {}, qpdfModulePromise = null; function setupSignEvents() { } function setupSignPDFEvents() { let e = document.getElementById("sign-file-input"); e && e.addEventListener("change", async e => { let t = e.target.files[0]; t && await handleSignFile(t) }), document.getElementById("tool-signature").addEventListener("click", () => openSignatureModal("draw")); let t = document.getElementById("stamp-modal"); document.getElementById("tool-stamp").addEventListener("click", () => { t.classList.remove("hidden") }), document.getElementById("close-stamp-modal").addEventListener("click", () => { t.classList.add("hidden") }), window.addEventListener("click", e => { e.target === t && t.classList.add("hidden") }), document.getElementById("tool-date").addEventListener("click", () => { let e = new Date().toLocaleDateString(); addSignText(e) }), document.getElementById("tool-sign-text").addEventListener("click", () => { addSignText("Text Here") }), window.currentSignZoom = 1; let a = () => { document.getElementById("sign-zoom-level").textContent = `${Math.round(100 * window.currentSignZoom)}%`, signCanvas && window.signBaseDims && (signCanvas.setZoom(window.currentSignZoom), signCanvas.setDimensions({ width: window.signBaseDims.width * window.currentSignZoom, height: window.signBaseDims.height * window.currentSignZoom }), signCanvas.requestRenderAll()) }; document.getElementById("sign-zoom-in").addEventListener("click", () => { window.currentSignZoom < 3 && (window.currentSignZoom += .25, a()) }), document.getElementById("sign-zoom-out").addEventListener("click", () => { window.currentSignZoom > .1 && (window.currentSignZoom -= .1, a()) }), document.getElementById("sign-zoom-reset").addEventListener("click", () => { window.currentSignZoom = 1, a() }), document.getElementById("tool-delete-sign").addEventListener("click", () => { if (!signCanvas) return; let e = signCanvas.getActiveObject(); e ? (signCanvas.remove(e), signCanvas.discardActiveObject(), signCanvas.requestRenderAll()) : showNotification("Select an item to delete..", "error") }), document.getElementById("save-signed-pdf-btn").addEventListener("click", saveSignedPdf), document.getElementById("clear-sign-btn").addEventListener("click", () => { "function" == typeof window.showConfirmModal ? window.showConfirmModal(() => { signCanvas.clear(), loadSignPage(currentSignPage) }) : confirm("Clear all signatures?") && (signCanvas.clear(), loadSignPage(currentSignPage)) }), setupSignatureModalEvents() } async function handleSignFile(e) { if (!e || "application/pdf" !== e.type) return; signFile = e, document.getElementById("sign-upload-area").classList.add("hidden"), document.getElementById("sign-editor-container").classList.remove("hidden"), signCanvas && (signCanvas.dispose(), signCanvas = null), signPageAnnotations = {}, currentSignPage = 1; let t = await e.arrayBuffer(), a = pdfjsLib.getDocument(t), n = await a.promise; totalSignPages = n.numPages, renderSignPageList(n), loadSignPage(1, n) } async function renderSignPageList(e) { let t = document.getElementById("sign-page-list"); t.innerHTML = ""; for (let a = 1; a <= e.numPages; a++) { let n = document.createElement("div"); n.className = `page-thumbnail ${1 === a ? "active" : ""}`, n.onclick = () => switchSignPage(a, e); let i = document.createElement("canvas"); n.appendChild(i); let r = document.createElement("span"); r.className = "page-number", r.innerText = a, n.appendChild(r), t.appendChild(n), renderThumbnailToCanvasDirect(e, a, i) } } async function renderThumbnailToCanvasDirect(e, t, a) { let n = await e.getPage(t), i = n.getViewport({ scale: .3 }); a.width = i.width, a.height = i.height, await n.render({ canvasContext: a.getContext("2d"), viewport: i }).promise } async function switchSignPage(e, t) { if (currentSignPage !== e) { if (signCanvas) { let a = signCanvas.toJSON(); delete a.backgroundImage, signPageAnnotations[currentSignPage] = a } currentSignPage = e, loadSignPage(e, t), document.querySelectorAll("#sign-page-list .page-thumbnail").forEach((t, a) => { t.classList.toggle("active", a + 1 === e) }) } } async function loadSignPage(e, t = null) { let a = t; if (!a) { let n = await signFile.arrayBuffer(); a = await pdfjsLib.getDocument(n).promise } let i = await a.getPage(e), r = i.getViewport({ scale: 1.5 }); window.signBaseDims = { width: r.width, height: r.height }; let l = document.querySelector("#sign-viewport .canvas-wrapper"); if (l) { let o = l.clientWidth - 40, s = o / r.width; window.currentSignZoom = Math.min(1, s) } else window.currentSignZoom = 1; document.getElementById("sign-canvas"), signCanvas ? (signCanvas.setDimensions({ width: r.width * window.currentSignZoom, height: r.height * window.currentSignZoom }), signCanvas.setZoom(window.currentSignZoom), signCanvas.clear()) : (signCanvas = new fabric.Canvas("sign-canvas", { width: r.width * window.currentSignZoom, height: r.height * window.currentSignZoom })).setZoom(window.currentSignZoom); let d = document.createElement("canvas"); d.width = r.width, d.height = r.height, await i.render({ canvasContext: d.getContext("2d"), viewport: r }).promise; let c = signPageAnnotations[e]; c ? signCanvas.loadFromJSON(c, () => { signCanvas.setBackgroundImage(d.toDataURL(), signCanvas.renderAll.bind(signCanvas), { scaleX: 1, scaleY: 1 }) }) : signCanvas.setBackgroundImage(d.toDataURL(), signCanvas.renderAll.bind(signCanvas), { scaleX: 1, scaleY: 1 }) } let drawingContext = null, isDrawing = !1, lastX = 0, lastY = 0; function setupSignatureModalEvents() { let e = document.getElementById("signature-modal"), t = document.getElementById("close-sign-modal"), a = document.getElementById("cancel-signature"), n = document.getElementById("create-signature-btn"), i = document.getElementById("signature-pad"); t.onclick = () => e.classList.add("hidden"), a.onclick = () => e.classList.add("hidden"), document.querySelectorAll(".sign-tabs .sign-tab-btn").forEach(e => { e.onclick = e => { document.querySelectorAll(".sign-tabs .sign-tab-btn").forEach(e => e.classList.remove("active")), document.querySelectorAll(".sign-tab-content").forEach(e => e.classList.add("hidden")), e.target.classList.add("active"), document.getElementById(`tab-${e.target.dataset.tab}`).classList.remove("hidden") } }), drawingContext = i.getContext("2d"); let r = [], l = (e, t) => { isDrawing = !0, r = [{ x: e, y: t }], drawingContext.lineWidth = document.getElementById("sign-width").value, drawingContext.lineCap = "round", drawingContext.lineJoin = "round", drawingContext.strokeStyle = document.getElementById("sign-color").value, drawingContext.beginPath(), drawingContext.arc(e, t, drawingContext.lineWidth / 2, 0, 2 * Math.PI, !0), drawingContext.fill(), drawingContext.closePath() }, o = (e, t) => { if (!isDrawing || (r.push({ x: e, y: t }), r.length < 3)) return; let a = r[r.length - 2], n = r[r.length - 1], i = { x: (a.x + r[r.length - 3].x) / 2, y: (a.y + r[r.length - 3].y) / 2 }, l = { x: (a.x + n.x) / 2, y: (a.y + n.y) / 2 }; drawingContext.beginPath(), drawingContext.moveTo(i.x, i.y), drawingContext.quadraticCurveTo(a.x, a.y, l.x, l.y), drawingContext.stroke(), drawingContext.closePath() }; i.addEventListener("mousedown", e => { l(e.offsetX, e.offsetY) }), i.addEventListener("mousemove", e => { o(e.offsetX, e.offsetY) }), i.addEventListener("mouseup", () => isDrawing = !1), i.addEventListener("mouseout", () => isDrawing = !1), i.addEventListener("touchstart", e => { e.preventDefault(); let t = e.touches[0], a = i.getBoundingClientRect(); l(t.clientX - a.left, t.clientY - a.top) }, { passive: !1 }), i.addEventListener("touchmove", e => { e.preventDefault(); let t = e.touches[0], a = i.getBoundingClientRect(); o(t.clientX - a.left, t.clientY - a.top) }, { passive: !1 }), i.addEventListener("touchend", () => isDrawing = !1), document.getElementById("clear-signature").onclick = () => { drawingContext.clearRect(0, 0, i.width, i.height) }, document.getElementById("sign-color").addEventListener("input", e => { drawingContext.strokeStyle = e.target.value }), n.onclick = () => { let t = document.querySelector(".sign-tabs .sign-tab-btn.active").dataset.tab, a = null; if ("draw" === t) a = i.toDataURL(); else if ("type" === t); else if ("upload" === t) { let n = document.getElementById("upload-preview"); n.src && (a = n.src) } if ("type" === t) { let r = document.getElementById("type-signature-input").value, l = document.querySelector(".font-btn.active")?.style.fontFamily || "Arial"; addSignText(r, { fontFamily: l, fontSize: 40, color: "#000000" }) } else a && fabric.Image.fromURL(a, e => { e.scaleToWidth(200), signCanvas.add(e), signCanvas.centerObject(e), signCanvas.setActiveObject(e) }); e.classList.add("hidden") }; let s = document.getElementById("type-signature-input"); s.addEventListener("input", updateTypePreview), document.querySelectorAll(".font-btn").forEach(e => { e.onclick = e => { document.querySelectorAll(".font-btn").forEach(e => e.classList.remove("active")), e.target.classList.add("active"), updateTypePreview() } }); let d = document.querySelector(".upload-box"), c = document.getElementById("upload-sign-file"); function g(e) { e.preventDefault(), e.stopPropagation() } function m(e) { d.classList.add("dragover") } function p(e) { d.classList.remove("dragover") } ["dragenter", "dragover", "dragleave", "drop"].forEach(e => { d.addEventListener(e, g, !1) }), ["dragenter", "dragover"].forEach(e => { d.addEventListener(e, m, !1) }), ["dragleave", "drop"].forEach(e => { d.addEventListener(e, p, !1) }), d.addEventListener("drop", function e(t) { let a = t.dataTransfer, n = a.files; if (n.length) { c.files = n; let i = new Event("change"); c.dispatchEvent(i) } }, !1), document.getElementById("upload-sign-file").addEventListener("change", e => { let t = e.target.files[0]; if (t) { let a = new FileReader; a.onload = e => { let t = document.getElementById("upload-preview"); t.src = e.target.result, t.classList.remove("hidden"), document.querySelector(".upload-box p").classList.add("hidden") }, a.readAsDataURL(t) } }) } function updateTypePreview() { let e = document.getElementById("type-signature-input").value || "Signature", t = document.querySelector(".font-btn.active")?.style.fontFamily || "cursive", a = document.getElementById("type-preview"); a.textContent = e, a.style.fontFamily = t } function openSignatureModal(e) { document.getElementById("signature-modal").classList.remove("hidden"), document.getElementById("clear-signature").click(), document.getElementById("type-signature-input").value = "", document.getElementById("type-preview").textContent = "" } function addSignText(e, t = {}) { if (!signCanvas) return; let a = new fabric.IText(e, { left: 100, top: 100, fontSize: t.fontSize || 20, fontFamily: t.fontFamily || "Arial", fill: t.color || "#000000" }); signCanvas.add(a), signCanvas.setActiveObject(a) } async function saveSignedPdf() { if (!signFile) return; if (signCanvas) { let e = signCanvas.toJSON(); delete e.backgroundImage, signPageAnnotations[currentSignPage] = e } let t = document.getElementById("save-signed-pdf-btn"); t.textContent = "Processing..."; try { let a = await signFile.arrayBuffer(), n = await PDFLib.PDFDocument.load(a), i = n.getPages(); for (let [r, l] of Object.entries(signPageAnnotations)) { let o = parseInt(r); if (0 === l.objects.length) continue; let s = i[o - 1], { width: d, height: c } = s.getSize(), g = document.createElement("canvas"); g.width = 1.5 * d, g.height = 1.5 * c; let m = new fabric.StaticCanvas(g); await new Promise(e => m.loadFromJSON(l, e)); let p = m.toDataURL({ format: "png" }), f = await n.embedPng(p); s.drawImage(f, { x: 0, y: 0, width: d, height: c }) } let v = await n.save(); downloadFile(v, "signed_document.pdf", "application/pdf") } catch (u) { console.error(u), showNotification("Error saving PDF", "error") } finally { t.textContent = "Sign & Download PDF" } } async function getQpdfModule() { return qpdfModulePromise || (qpdfModulePromise = (async () => { try { let e = (await import("https://cdn.jsdelivr.net/npm/@jspawn/qpdf-wasm/qpdf.mjs")).default, t = await e({ locateFile: () => "https://cdn.jsdelivr.net/npm/@jspawn/qpdf-wasm/qpdf.wasm" }); return t } catch (a) { throw console.error("qpdf-wasm load error:", a), Error("Failed to load CDN. Check network availability.") } })()) } function setupProtectPDFEvents() { let e = document.getElementById("protect-upload-area"), t = document.getElementById("protect-file-input"), a = document.getElementById("protect-btn"), n = document.getElementById("protect-password"); n && n.addEventListener("input", e => updatePasswordStrength(e.target.value)), e && (e.addEventListener("dragover", t => { t.preventDefault(), e.classList.add("dragover") }), e.addEventListener("dragleave", () => { e.classList.remove("dragover") }), e.addEventListener("drop", t => { t.preventDefault(), e.classList.remove("dragover"), t.dataTransfer && t.dataTransfer.files && t.dataTransfer.files[0] && handleProtectFile(t.dataTransfer.files[0]) })), t && t.addEventListener("change", e => { e.target.files && e.target.files[0] && handleProtectFile(e.target.files[0]) }), a && a.addEventListener("click", protectPDF) } function handleProtectFile(e) {
    if (!e) return; let t = "application/pdf" === e.type, a = /\.pdf$/i.test(e.name); if (!t && !a) { showNotification("Please upload a PDF file.", "warning"); return } protectFile = e; let n = document.getElementById("protect-upload-area"), i = document.getElementById("protect-settings-container"); n && n.classList.add("hidden"), i && i.classList.remove("hidden"); let r = document.getElementById("protect-file-info"); r && (r.innerHTML = `
        <div class="file-item" style="margin:0; border:var(--primary-color) 1px solid;">
            <div class="file-info">${e.name}</div>
            <div class="file-controls">
                <button class="btn-icon remove" onclick="removeProtectFile()" title="Remove">
                    <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                </button>
            </div>
        </div>
    `)
} function updatePasswordStrength(e) { let t = document.getElementById("password-strength-bar"), a = document.getElementById("password-strength-text"); if (!t || !a) return; if (t.className = "strength-bar", !e) { t.style.width = "0", a.textContent = "Password Strength: -"; return } let n = 0; e.length >= 6 && n++, e.length >= 10 && n++, /[A-Z]/.test(e) && n++, /[0-9]/.test(e) && n++, /[^A-Za-z0-9]/.test(e) && n++, n < 2 ? (t.classList.add("weak"), t.style.width = "20%", a.textContent = "Weak") : n < 4 ? (t.classList.add("medium"), t.style.width = "60%", a.textContent = "Medium") : (t.classList.add("strong"), t.style.width = "100%", a.textContent = "Strong") } async function protectPDF() { let e = document.getElementById("protect-btn"); try { if (!protectFile) { showNotification("Please upload a PDF file.", "warning"); return } let t = document.getElementById("protect-password").value, a = document.getElementById("protect-password-confirm").value; if (!t) { showNotification("Please enter a password.", "warning"); return } if (t !== a) { showNotification("Passwords do not match.", "error"); return } e && (e.disabled = !0, e.textContent = "Encrypting..."); let n = await protectFile.arrayBuffer(), i = new Uint8Array(n), r = await getQpdfModule(), l = "/input.pdf", o = "/output.pdf"; try { r.FS.analyzePath("/").exists } catch (s) { } try { try { r.FS.unlink(l) } catch (d) { } try { r.FS.unlink(o) } catch (c) { } r.FS.writeFile(l, i) } catch (g) { throw console.error("FS write error:", g), Error("Failed to write file to qpdf virtual FS: " + g.message) } try { r.callMain(["--encrypt", t, t, "256", "--", l, o]) } catch (m) { throw console.error("qpdf callMain error:", m), Error("qpdf failed to encrypt PDF. See console for details.") } let p; try { p = r.FS.readFile(o) } catch (f) { throw console.error("qpdf read error:", f), Error("Encrypted output not found. qpdf may have failed.") } let v = new Blob([p], { type: "application/pdf" }), u = `protected_${protectFile.name.replace(/\.pdf$/i, "")}.pdf`; try { triggerDownloadAnimation(e) } catch (h) { } try { downloadFile(v, u) } catch (y) { let E = URL.createObjectURL(v), w = document.createElement("a"); w.href = E, w.download = u, document.body.appendChild(w), w.click(), w.remove(), setTimeout(() => URL.revokeObjectURL(E), 2e3) } showNotification("PDF encrypted successfully!", "success"); try { r.FS.unlink(l), r.FS.unlink(o) } catch (b) { } try { document.getElementById("protect-password").value = "", document.getElementById("protect-password-confirm").value = "", updatePasswordStrength("") } catch ($) { } } catch (L) { console.error("protectPDF error", L), showNotification("Error protecting PDF. " + (L && L.message ? L.message : L), "error") } finally { e && (e.disabled = !1, e.textContent = "Protect & Download PDF") } } window.addStamp = function (e, t) { if (!signCanvas) return; let a = new fabric.Group([], { position: "relative", left: 250, top: 250, originX: "center", originY: "center" }), n = new fabric.Rect({ width: 200, height: 60, fill: "transparent", stroke: t, strokeWidth: 5, rx: 10, ry: 10, originX: "center", originY: "center" }), i = new fabric.Text(e, { fontSize: 32, fontFamily: "Impact, Arial Black, sans-serif", fill: t, originX: "center", originY: "center", fontWeight: "bold", charSpacing: 50 }); a.addWithUpdate(n), a.addWithUpdate(i), signCanvas.add(a), signCanvas.setActiveObject(a), signCanvas.requestRenderAll(); let r = document.getElementById("stamp-modal"); r && r.classList.add("hidden") }, window.removeProtectFile = () => { protectFile = null; let e = document.getElementById("protect-file-info"), t = document.getElementById("protect-upload-area"), a = document.getElementById("protect-settings-container"), n = document.getElementById("protect-password"), i = document.getElementById("protect-password-confirm"), r = document.getElementById("protect-file-input"); r && (r.value = ""), n && (n.value = ""), i && (i.value = ""), updatePasswordStrength(""), a && a.classList.add("hidden"), t && t.classList.remove("hidden"), e && (e.innerHTML = "") }, "loading" === document.readyState ? document.addEventListener("DOMContentLoaded", setupProtectPDFEvents) : setupProtectPDFEvents(), document.addEventListener("click", function (e) { if (e.target.matches(".toggle-password") || e.target.closest(".toggle-password")) { e.preventDefault(); let t = e.target.matches(".toggle-password") ? e.target : e.target.closest(".toggle-password"), a = t.closest(".password-input-wrapper"), n = a ? a.querySelector("input") : null; n ? "password" === n.type ? (n.type = "text", t.textContent = "\uD83D\uDC41") : (n.type = "password", t.textContent = "\uD83D\uDE48") : (console.log("No input found!"), showNotification("No input found!", "warning")) } }); let rotateFile = null, rotationStates = []; function handleRotateFile(e) { if (!e) return; if ("application/pdf" !== e.type) { showNotification("Please upload a PDF file", "warning"); return } rotateFile = e; let t = document.getElementById("rotate-upload-area"), a = document.getElementById("rotate-controls"); t && t.classList.add("hidden"), a && a.classList.remove("hidden"), renderRotatePreviews(e) } async function renderRotatePreviews(e) {
    let t = document.getElementById("rotate-previews"); if (t) {
        t.innerHTML = "<p>Loading pages...</p>"; try {
            let a = await e.arrayBuffer(), n = await pdfjsLib.getDocument(a).promise; t.innerHTML = "", rotationStates = Array(n.numPages).fill(0); for (let i = 1; i <= n.numPages; i++) {
                let r = await n.getPage(i), l = r.getViewport({ scale: .3 }), o = document.createElement("div"); o.className = "page-item", o.innerHTML = `
                <div class="page-canvas-container">
                    <canvas id="rotate-canvas-${i}"></canvas>
                </div>
                <div class="rotate-actions">
                    <button class="rotate-btn" onclick="rotatePage(${i - 1})" title="Rotate 90\xb0 Clockwise">
                        <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="23 4 23 10 17 10"></polyline><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path></svg>
                    </button>
                </div>
                <div class="page-label">Page ${i}</div>
            `, t.appendChild(o); let s = o.querySelector("canvas"); s.height = l.height, s.width = l.width; let d = { canvasContext: s.getContext("2d"), viewport: l }; r.render(d)
            }
        } catch (c) { console.error(c), showNotification("Error loading PDF pages", "error") }
    }
} async function downloadRotatedPDF() { if (!rotateFile) return; let e = document.getElementById("download-rotated-btn"); e.disabled = !0, e.textContent = "Processing..."; try { let t = await rotateFile.arrayBuffer(), a = await PDFLib.PDFDocument.load(t), n = a.getPages(); n.forEach((e, t) => { let a = rotationStates[t] || 0; if (a > 0) { let n = e.getRotation().angle; e.setRotation(PDFLib.degrees(n + a)) } }); let i = await a.save(); downloadFile(i, `rotated_${rotateFile.name}`), showNotification("Rotated PDF downloaded!", "success") } catch (r) { console.error(r), showNotification("Failed to save PDF", "error") } finally { e.disabled = !1, e.textContent = "Download Rotated PDF" } } function setupZoomPan() { let e = document.getElementById("zoom-in"), t = document.getElementById("zoom-out"), a = document.getElementById("zoom-fit"); e && e.addEventListener("click", () => setZoom(editZoom + .1)), t && t.addEventListener("click", () => setZoom(editZoom - .1)), a && a.addEventListener("click", () => { editPanX = 0, editPanY = 0, setZoom(1) }); let n = document.getElementById("tool-hand"); n && n.addEventListener("click", () => setEditTool("hand")); let i = document.getElementById("editor-viewport"); if (!i) return; i.addEventListener("mousedown", e => { "hand" === currentEditTool && (isPanning = !0, startPanX = e.clientX - editPanX, startPanY = e.clientY - editPanY, i.classList.add("grabbing")) }), window.addEventListener("mousemove", e => { isPanning && "hand" === currentEditTool && (e.preventDefault(), editPanX = e.clientX - startPanX, editPanY = e.clientY - startPanY, applyZoomPanTransforms()) }), window.addEventListener("mouseup", () => { isPanning && (isPanning = !1, i.classList.remove("grabbing")) }), i.addEventListener("wheel", e => { if (e.ctrlKey) { e.preventDefault(); let t = e.deltaY > 0 ? -.1 : .1; setZoom(editZoom - t) } }, { passive: !1 }); let r = document.getElementById("zoom-controls"); r && r.classList.remove("hidden") } function setZoom(e) { e < .1 && (e = .1), e > 5 && (e = 5), editZoom = parseFloat(e.toFixed(2)); let t = document.getElementById("zoom-level"); t && (t.textContent = Math.round(100 * editZoom) + "%"), applyZoomPanTransforms() } function applyZoomPanTransforms() { let e = document.getElementById("editor-transform-layer"); e && (e.style.transform = `translate(${editPanX}px, ${editPanY}px) scale(${editZoom})`) } window.rotatePage = e => { rotationStates[e] = (rotationStates[e] + 90) % 360; let t = document.getElementById(`rotate-canvas-${e + 1}`); t && (t.style.transform = `rotate(${rotationStates[e]}deg)`) }, document.addEventListener("DOMContentLoaded", () => { let e = document.getElementById("rotate-file-input"), t = document.getElementById("rotate-upload-area"), a = document.getElementById("download-rotated-btn"); e && e.addEventListener("change", e => { e.target.files && e.target.files[0] && handleRotateFile(e.target.files[0]) }), t && (t.addEventListener("dragover", e => { e.preventDefault(), t.classList.add("dragover") }), t.addEventListener("dragleave", () => { t.classList.remove("dragover") }), t.addEventListener("drop", e => { e.preventDefault(), t.classList.remove("dragover"), e.dataTransfer.files && e.dataTransfer.files[0] && handleRotateFile(e.dataTransfer.files[0]) })), a && a.addEventListener("click", downloadRotatedPDF) }), document.addEventListener("DOMContentLoaded", init); let pnState = { position: "bc", format: "1", fontSize: 12, margin: 10, color: "#000000", font: "Helvetica", range: "all", customRange: "" }; const fontUrls = { Roboto: "fonts/Roboto-Regular.ttf", OpenSans: "fonts/OpenSans-Regular.ttf", Lato: "fonts/Lato-Regular.ttf", Montserrat: "fonts/Montserrat-Regular.ttf", Oswald: "fonts/Oswald-Regular.ttf", Raleway: "fonts/Raleway-Regular.ttf", Merriweather: "fonts/Merriweather-Regular.ttf", PTSans: "fonts/PTSans-Regular.ttf" }; function initPageNumbers() { let e = document.querySelectorAll("#pn-position-grid button"); e.forEach(t => { t.addEventListener("click", t => { e.forEach(e => e.classList.remove("active")), t.target.classList.add("active"), pnState.position = t.target.getAttribute("data-pos") }) }); let t = document.getElementById("pn-format"); t && t.addEventListener("change", e => { pnState.format = e.target.value }); let a = document.getElementById("pn-font-family"); a && a.addEventListener("change", e => { pnState.font = e.target.value }); let n = document.getElementById("pn-fontsize"); n && n.addEventListener("input", e => { pnState.fontSize = parseInt(e.target.value); let t = document.getElementById("pn-fontsize-val"); t && (t.textContent = pnState.fontSize) }); let i = document.getElementById("pn-margin"); i && i.addEventListener("input", e => { pnState.margin = parseInt(e.target.value); let t = document.getElementById("pn-margin-val"); t && (t.textContent = pnState.margin) }); let r = document.getElementById("pn-color"); r && r.addEventListener("input", e => { pnState.color = e.target.value }); let l = document.querySelectorAll("#page-number-controls .wm-toggle button"), o = document.getElementById("pn-custom-range"); l.forEach(e => { e.addEventListener("click", e => { l.forEach(e => e.classList.remove("active")), e.target.classList.add("active"), "pn-range-custom" === e.target.id ? (pnState.range = "custom", o && o.classList.remove("hidden")) : (pnState.range = "all", o && o.classList.add("hidden")) }) }), o && o.addEventListener("input", e => { pnState.customRange = e.target.value }); let s = document.getElementById("apply-page-numbers-btn"); s && (s.onclick = applyPageNumbers) } async function applyPageNumbers() { let e = originalEditFile || editFile; if (!e) { showNotification("Please upload a PDF first", "warning"); return } let t = document.getElementById("apply-page-numbers-btn"); t.disabled = !0, t.textContent = "Processing..."; try { let a = await e.arrayBuffer(), n = await PDFLib.PDFDocument.load(a), i = n.getPages(); window.fontkit && n.registerFontkit(window.fontkit); let r; if (fontUrls[pnState.font]) try { let l = await fetch(fontUrls[pnState.font]).then(e => e.arrayBuffer()); r = await n.embedFont(l) } catch (o) { console.error("Error loading custom font", o), showNotification("Failed to load font. Using Standard.", "warning"), r = await n.embedFont(PDFLib.StandardFonts.Helvetica) } else r = "TimesRoman" === pnState.font ? await n.embedFont(PDFLib.StandardFonts.TimesRoman) : "Courier" === pnState.font ? await n.embedFont(PDFLib.StandardFonts.Courier) : await n.embedFont(PDFLib.StandardFonts.Helvetica); let s = i.length, d = []; if ("all" === pnState.range) d = i.map((e, t) => t); else { let c = pnState.customRange.split(","); c.forEach(e => { if ((e = e.trim()).includes("-")) { let [t, a] = e.split("-").map(e => parseInt(e)); if (!isNaN(t) && !isNaN(a)) for (let n = t; n <= a; n++)n >= 1 && n <= s && d.push(n - 1) } else { let i = parseInt(e); !isNaN(i) && i >= 1 && i <= s && d.push(i - 1) } }), d = [...new Set(d)].sort((e, t) => e - t) } d.forEach(e => { let t = i[e], { width: a, height: n } = t.getSize(), l = e + 1, o = ""; "1" === pnState.format ? o = "" + l : "page-of" === pnState.format ? o = "Page " + l + " of " + s : "fraction" === pnState.format && (o = l + " / " + s); let d = r.widthOfTextAtSize(o, pnState.fontSize), c = r.heightAtSize(pnState.fontSize), g = 0, m = 0, p = pnState.margin; pnState.position.includes("l") ? g = p : pnState.position.includes("c") ? g = (a - d) / 2 : pnState.position.includes("r") && (g = a - d - p), m = pnState.position.startsWith("t") ? n - c - p : p; let f = hexToRgb(pnState.color); t.drawText(o, { x: g, y: m, size: pnState.fontSize, font: r, color: PDFLib.rgb(f.r / 255, f.g / 255, f.b / 255) }) }); let g = await n.save(), m = new Blob([g], { type: "application/pdf" }), p = new File([m], e.name, { type: "application/pdf" }); await handleEditFile(p, !0), showNotification('Page numbers applied. Please review and click "Save & Download PDF" to finish.', "success") } catch (f) { console.error(f), showNotification("Error adding page numbers", "error") } finally { t.disabled = !1, t.textContent = "Add Page Numbers" } } function hexToRgb(e) { let t = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(e); return t ? { r: parseInt(t[1], 16), g: parseInt(t[2], 16), b: parseInt(t[3], 16) } : { r: 0, g: 0, b: 0 } }